<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <title>XML Parser Class  &#8211; ExpressionEngine Developer Documentation</title>

  <meta name="MSSmartTagsPreventParsing" content="TRUE" />
  <link rel="contents" href="../../index.html" />
  <style type="text/css" media="screen,print">@import url(../../docs.css);</style>
</head>

<body>
<div><a name="top"></a></div>


<div id="header">
<table cellpadding="0" cellspacing="0" border="0" style="width:100%;"><tr>
<td class="docheading" style="width:300px;"><a href="../../index.html"><img src="../../images/user_guide.gif" width="231" height="24" alt="ExpressionEngine User Guide" /></a></td>
<td class="searchbox"><form method="get" action="http://www.google.com/search" class="searchbox"><div>Search&nbsp;&nbsp;<input type="text" class="input" name="q" id="q" size="31" maxlength="255" value="" /><input type="hidden" name="as_sitesearch" id="as_sitesearch" value="ee1docs.com" />&nbsp;<input type="submit" class="submit" name="sa" value="Search" /></div></form></td>
</tr>
</table>
</div>


<div id="navlinks">
<a href="../../index.html">Table of Contents</a> &gt;
<a href="../index.html">Development</a> &gt;
<strong>XML Parser Class</strong>
</div>


<div id="content">
<h1>XML Parser Class</h1>

<div class="section">
	<ul>
		<li><a href="xmlparser.html#calling">Calling the XML Parser Class</a></li>
		<li><a href="xmlparser.html#parsing_xml">Parsing XML</a></li>
		<li><a href="xmlparser.html#converting">Converting Delimited Text to XML</a></li>
	</ul>
</div>


<a name="calling"></a>
<div class="section">
<h2>Calling the XML Parser Class</h2>

<p>ExpressionEngine has an abstracted XML parser that enables developers to work with XML information more easily than with PHP's built-in XML functions.</p>

<p>To use the XML parser in your modules, you need to first instantiate the XML Parser Class</p>

<pre>
if ( ! class_exists('EE_XMLparser'))
{
    require PATH_CORE.'core.xmlparser'.EXT;
}

$XML = new EE_XMLparser;
</pre>
</div>


<a name="parsing_xml"></a>
<div class="section">
<h2>Parsing XML</h2>

<h3>Description</h3>

<p>obj <strong>$XML->parse_xml </strong>( string xml )</p>

<p>This function returns an abstracted object containing all of the tags, attributes, and values from the XML.  The string parameter must be valid and well-formed XML.  Below is an example of the structures generated by this function.</p>

<h3>Sample XML</h3>

<pre>$simple = "&lt;emails>
			&lt;email>
				&lt;from>Samantha&lt;/from>
				&lt;to>Gertrude&lt;/to>
				&lt;subject>You coming to the party?&lt;/subject>
				&lt;message type='urgent'>It starts at 9pm.  Don't forget to bring the gruyère!&lt;/message>
			&lt;/email>
		&lt;/emails>";
</pre>

<h3>Using $XML->parse_xml()</h3>

<pre>$xml_obj = $XML->parse_xml($simple);</pre>

<h3>Structure of $XML->parse_xml()</h3>

<pre>xml_cache Object
(
    [tag] => emails
    [attributes] => 
    [value] => 
    [children] => Array
        (
            [0] => xml_cache Object
                (
                    [tag] => email
                    [attributes] => 
                    [value] => 
                    [children] => Array
                        (
                            [0] => xml_cache Object
                                (
                                    [tag] => from
                                    [attributes] => 
                                    [value] => Samantha
                                    [children] => 
                                )

                            [1] => xml_cache Object
                                (
                                    [tag] => to
                                    [attributes] => 
                                    [value] => Gertrude
                                    [children] => 
                                )

                            [2] => xml_cache Object
                                (
                                    [tag] => subject
                                    [attributes] => 
                                    [value] => You coming to the party?
                                    [children] => 
                                )

                            [3] => xml_cache Object
                                (
                                    [tag] => message
                                    [attributes] => Array
                                        (
                                            [type] => urgent
                                        )

                                    [value] => It starts at 9pm.  Don't forget to bring the gruyère!
                                    [children] => 
                                )

                        )

                )

        )

)</pre>

<p>With this structure, each tag as an array of objects for each child.  In addition to the <strong>children</strong> array, there are three other variables for each tag object.</p>

<dl>
	<dt>tag</dt>
	<dd>The tag's name.</dd>
	
	<dt>attributes</dt>
	<dd>If present, they are stored as an array of <samp>$key => $val</samp> pairs.</dd>
	
	<dt>value</dt>
	<dd>The contents of the tag.</dd>
</dl>

<a name="converting"></a>
<div class="section">
<h2>Converting Delimited Text to XML</h2>

<p>The XML Parser class includes a function to help you create XML from delimited data.</p>

<h3>Description</h3>

<p>string <strong>$XML->delimited_to_xml</strong> ( array parameters )</p>

<p>Takes delimited data and returns XML.  Returns <kbd>FALSE</kbd> if unable to create XML, and uses the XML class <samp>$errors</samp> array to log errors encountered.  You should always check the <samp>$errors</samp> array before using the returned XML.</p>

<h3>Parameters</h3>

<p>This method takes an array of parameters, using the following keys:</p>

<dl>
	<dt>data</dt>
	<dd>(string) delimited text data (comma-delimited, tab-delimited, quote-enclosed, etc.)</dd>
	
	<dt>structure</dt>
	<dd>(array) structure of the delimited data.</dd>
	
	<dt>root</dt>
	<dd>(string) The root XML document tag name.  Default is <strong>'root'</strong></dd>
	
	<dt>element</dt>
	<dd>(string) The name of the primary element that will be used to enclose each record / row of data.  Default is <strong>'element'</strong></dd>
	
	<dt>delimiter</dt>
	<dd>(string) The character delimiting the text.  The default is <strong>\t</strong> (tab).</dd>
	
	<dt>enclosure</dt>
	<dd>(string) Character used to enclose the data, such as <strong>"</strong> in the case of $data = '"item1", "item2", "item3"';  Default is none (empty string)</dd>
</dl>

<h3>Sample data</h3>

<pre>
$data = "Samantha|Gertrude|You coming to the party?|It starts at 9pm.  Don't forget to bring the gruyère!
Inigo|Westley|I know something you don't know.|I am not left-handed!";

$structure = array("from", "to", "subject", "message");

$delimiter = "|";

$root = "emails";

$element = "email";
</pre>

<h3>Using $XML->delimited_to_xml()</h3>

<pre>
$params = array(
		'data'		=> $data,
		'structure'	=> $structure,
		'delimiter'	=> $delimiter,
		'root'		=> $root,
		'element'	=> $element
		);
					
$xml = $XML->delimited_to_xml($params);</pre>

<h3>Result</h3>

<pre>&lt;emails>
	&lt;email>
		&lt;from>Samantha&lt;/from>
		&lt;to>Gertrude&lt;/to>
		&lt;subject>You coming to the party?&lt;/subject>
		&lt;message>It starts at 9pm.  Don't forget to bring the gruyère!&lt;/message>
	&lt;/email>
	&lt;email>
		&lt;from>Inigo&lt;/from>
		&lt;to>Westley&lt;/to>
		&lt;subject>I know something you don't know.&lt;/subject>
		&lt;message>I am not left-handed!&lt;/message>
	&lt;/email>
&lt;/emails></pre>

<h3>Checking for Errors</h3>

<p>You should always check for the presence of errors before using the returned XML.  This will allow you to tell which records were skipped and unable to be used in the XML.  <samp>$XML->delimited_to_xml()</samp> will only return <kbd>FALSE</kbd> on fatal errors, as in some cases it may be acceptable to ignore the errors.</p>

<p>Errors are logged in the <samp>$XML->errors</samp> array.  Below is an example of how you might use them.</p>

<pre>
if ( ! empty($XML->errors))
{
	echo "Could not convert to XML:&lt;br />&lt;br />";
	
	foreach ($XML->errors as $error)
	{
		echo "{$error}&lt;br />";
		exit;
	}
}
</pre>

<p>You can also take advantage of the <samp>show_user_error()</samp> method from the Output class to generate an ExpressionEngine style error page:</p>

<pre>
global $OUT;

if ( ! empty($XML->errors))
{
	$OUT->show_user_error('general', $XML->errors);
	exit;
}
</pre>
</div>

<a name="converting_old"></a>
<div class="section">
<h2>Converting Delimited Text to XML (old way)</h2>

<p>The original XML Parser class utlized the following function to help you create XML from delimited data.</p>

<h3>Description</h3>

<p>string <strong>$XML->data2xml</strong> ( string data, array structure, string root, string element, string delimiter, string enclosure )</p>

<p>Takes delimited data and returns XML.</p>

<p class="important"><strong>NOTE: </strong><samp>data2xml()</samp> has been deprecated.  Your existing code will still work, but this method has been replaced with <samp>delimited_to_xml()</samp></p>
</div>






</div>

<p class="center"><a href="#top">Top of Page</a></p>

<!-- {user_guide_comments} -->

<div id="footer">
  <address><a href="http://expressionengine.com/">ExpressionEngine</a> &#8211; Copyright &#169; 2002-2012 &#8211; <a href="http://ellislab.com/">EllisLab, Inc.</a></address>
</div>

</body>
</html>